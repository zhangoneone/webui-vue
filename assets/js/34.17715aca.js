(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{426:function(t,e,s){"use strict";s.r(e);var a=s(42),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"unit-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unit-testing"}},[t._v("#")]),t._v(" Unit Testing")]),t._v(" "),s("p",[t._v("The goal of a unit test is to improve code quality and assure future development or refactoring does not result in broken builds and functionality. Tests that require consistent updating when refactoring code are likely tightly coupled to the internals of the component.")]),t._v(" "),s("blockquote",[s("p",[t._v("Writing unit tests is a constant struggle between writing enough tests and not writing too many. I call this the unit testing Goldilocks ruleâ€”not too many, not too few, but just enough. Thousands of tests for a small application can be as damaging to development time as no tests.")]),t._v(" "),s("p",[t._v("-- "),s("cite",[t._v("Ed Yerburgh, Testing Vue Applications (New York: Manning Publications, 2019)")])])]),t._v(" "),s("h2",{attrs:{id:"test-libraries"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#test-libraries"}},[t._v("#")]),t._v(" Test Libraries")]),t._v(" "),s("p",[t._v("The OpenBMC Web UI unit test framework uses the Jest test runner and relies on the following libraries:")]),t._v(" "),s("ul",[s("li",[t._v("@vue/cli-plugin-unit-jest")]),t._v(" "),s("li",[t._v("@vue/test-utils")])]),t._v(" "),s("h2",{attrs:{id:"test-specification-location-and-naming-conventions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#test-specification-location-and-naming-conventions"}},[t._v("#")]),t._v(" Test specification location and naming conventions")]),t._v(" "),s("ul",[s("li",[t._v("Create the test files in the /tests/unit directory")]),t._v(" "),s("li",[t._v("The naming convention is to replicate the folder and component name")])]),t._v(" "),s("h3",{attrs:{id:"examples"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[t._v("#")]),t._v(" Examples")]),t._v(" "),s("ul",[s("li",[t._v("The AppHeader.vue single-file component's (SFC) spec file is named "),s("code",[t._v("AppHeader.spec.js")])]),t._v(" "),s("li",[t._v("Create a global component like "),s("code",[t._v("PageSection.vue")]),t._v(" in the "),s("code",[t._v("/tests/global")]),t._v(" directory with the name "),s("code",[t._v("PageSection.spec.js")])]),t._v(" "),s("li",[t._v("Create a mixin like BVToastMixin  in the "),s("code",[t._v("/tests/mixins")]),t._v(" directory with the name "),s("code",[t._v("BVToastMixin.spec.js")]),t._v(" Running Tests")])]),t._v(" "),s("h2",{attrs:{id:"running-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#running-tests"}},[t._v("#")]),t._v(" Running Tests")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("test:unit")]),t._v(" script will run all the test suites. Until the integration of the test script with the continuous integration tool is complete, it needs to be run manually before pushing up code for review. If you are working on fixing a test that is failing, follow the guidelines for debugging a failed tests or fixing failed snapshot tests.")]),t._v(" "),s("h3",{attrs:{id:"debugging-a-failed-test"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#debugging-a-failed-test"}},[t._v("#")]),t._v(" Debugging a failed test")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("test:unit:debugger")]),t._v(" script will help to debug failing tests using the Chrome Developer Tools. To debug a test:")]),t._v(" "),s("ol",[s("li",[t._v("Add a "),s("code",[t._v("debugger")]),t._v(" statement in the specifications file")]),t._v(" "),s("li",[t._v("Run the unit test in debugger mode")]),t._v(" "),s("li",[t._v("Open the Chrome browser and go to "),s("code",[t._v("chrome://inspect")])])]),t._v(" "),s("h3",{attrs:{id:"fixing-failed-snapshot-tests"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fixing-failed-snapshot-tests"}},[t._v("#")]),t._v(" Fixing failed snapshot tests")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("test:update")]),t._v(" script will update snapshot tests. If the UI has changed and the snapshot tests are failing, after manually verifying the UI changes, run the update script to update the snapshots. Running "),s("code",[t._v("test:updat")]),t._v("e can be dangerous, as it will update all snapshot tests.")]),t._v(" "),s("p",[t._v("It is critical to verify all snapshot tests before running the update script. The easiest way is to run the unit test in watch mode, "),s("code",[t._v("npm run test:unit -- --watch")]),t._v(" and verify each snapshot.")]),t._v(" "),s("h2",{attrs:{id:"guidelines"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#guidelines"}},[t._v("#")]),t._v(" Guidelines")]),t._v(" "),s("ul",[s("li",[t._v("Avoid coupling test code to source code when testing functionality\n"),s("ul",[s("li",[t._v("If test cases fail during refactoring, the test case may be tightly coupled with the application structure.")])])]),t._v(" "),s("li",[t._v("A test should not break if the functionality it tests has not changed")]),t._v(" "),s("li",[t._v("To maintain test readability, only pass in the data needed for the test to work in your mock object")]),t._v(" "),s("li",[t._v("Avoid the creation of side-effects whenever possible")]),t._v(" "),s("li",[t._v("There is no return on investment for testing presentational HTML")]),t._v(" "),s("li",[t._v("Use "),s("code",[t._v("shallowMount")]),t._v(" rather than mount unless child component rendering is required")]),t._v(" "),s("li",[t._v("Avoid leaky tests by using "),s("code",[t._v("localVue")]),t._v(" for all plugin installs, for example, when testing a plugin like Vuex")])]),t._v(" "),s("h2",{attrs:{id:"components"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#components"}},[t._v("#")]),t._v(" Components")]),t._v(" "),s("h3",{attrs:{id:"what-to-test"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-to-test"}},[t._v("#")]),t._v(" What to test")]),t._v(" "),s("ol",[s("li",[t._v("Test the function's inputs and outputs\n"),s("ul",[s("li",[t._v("Test only dynamically generated output")]),t._v(" "),s("li",[t._v("Test only output that is part of the component contract")])])]),t._v(" "),s("li",[t._v("Test any side-effects")]),t._v(" "),s("li",[t._v("Test correct rendering using a snapshot test")])]),t._v(" "),s("h3",{attrs:{id:"what-not-to-test"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-not-to-test"}},[t._v("#")]),t._v(" What not to test")]),t._v(" "),s("ol",[s("li",[t._v("Don't test third-party functionality")]),t._v(" "),s("li",[t._v("Don't test the internals of your components or that specific functions are called. This can lead to unnecessary refactoring.")]),t._v(" "),s("li",[t._v("Don't go beyond the input and outputs of the component")]),t._v(" "),s("li",[t._v("Don't test the functionality of other libraries")]),t._v(" "),s("li",[t._v("Static components do not need unit tests, use snapshot testing")])]),t._v(" "),s("h3",{attrs:{id:"strategy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#strategy"}},[t._v("#")]),t._v(" Strategy")]),t._v(" "),s("ol",[s("li",[t._v("Define a component contract that is based upon the component API")]),t._v(" "),s("li",[t._v("Create smaller functions with a specific purpose to make testing easier")]),t._v(" "),s("li",[t._v("Test the component API by writing tests first and then writing code to fix the tests")]),t._v(" "),s("li",[t._v("Add a snapshot test once the presentational layer is validated through manual visual testing")])]),t._v(" "),s("h3",{attrs:{id:"snapshot-testing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#snapshot-testing"}},[t._v("#")]),t._v(" Snapshot Testing")]),t._v(" "),s("p",[t._v("A snapshot test is a comparison of the code from two different points in time. When the view is rendering as expected, a snapshot is taken and when the test suite is run, this snapshot is compared to the current code to make sure nothing has changed.")]),t._v(" "),s("p",[t._v("This type of testing is good for testing that static content output has not changed due to any code updates or refactoring. Too many snapshots can slow down development during refactors. Typically, these are written once the UI presentational layer is complete and validated.")]),t._v(" "),s("h2",{attrs:{id:"vuex-store"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-store"}},[t._v("#")]),t._v(" Vuex Store")]),t._v(" "),s("p",[t._v("There are two testing strategies for testing a Vuex store, which include testing store parts separately or testing a running store instance. Each strategy has its pros and cons. Given the size of the store and the number of developers that could potentially contribute to the project, the suggested strategy is to "),s("code",[t._v("test store parts separately")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"testing-store-parts-separately"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#testing-store-parts-separately"}},[t._v("#")]),t._v(" Testing Store Parts Separately")]),t._v(" "),s("p",[t._v("Testing the parts separately is easy since each of the parts is a JavaScript function. Store parts to test include "),s("code",[t._v("actions")]),t._v(", "),s("code",[t._v("getters")]),t._v(", and "),s("code",[t._v("mutations")]),t._v(".")]),t._v(" "),s("h4",{attrs:{id:"actions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#actions"}},[t._v("#")]),t._v(" Actions")]),t._v(" "),s("p",[t._v("Since HTTP calls should never be used in a test, actions require extreme mocking. Mocking tests rely on assumptions and can lead to faulty tests.")]),t._v(" "),s("h4",{attrs:{id:"getters"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#getters"}},[t._v("#")]),t._v(" Getters")]),t._v(" "),s("p",[t._v("Getters are JavaScript functions that return an output. These are basic functions that may not require testing unless there is getter logic. Any logic in a getter should be tested.")]),t._v(" "),s("h4",{attrs:{id:"mutations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mutations"}},[t._v("#")]),t._v(" Mutations")]),t._v(" "),s("p",[t._v("Mutations are JavaScript functions that mutate the store state. These are basic functions that may not require testing unless there is mutation logic. Any logic in a mutation should be tested.")]),t._v(" "),s("h4",{attrs:{id:"pros"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pros"}},[t._v("#")]),t._v(" Pros")]),t._v(" "),s("ul",[s("li",[t._v("Easier to debug")]),t._v(" "),s("li",[t._v("Smaller tests")])]),t._v(" "),s("h4",{attrs:{id:"cons"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cons"}},[t._v("#")]),t._v(" Cons")]),t._v(" "),s("ul",[s("li",[t._v("Requires extreme mocking when testing actions")]),t._v(" "),s("li",[t._v("Tightly coupled with implementation details")]),t._v(" "),s("li",[t._v("More maintenance required when refactoring")])]),t._v(" "),s("h3",{attrs:{id:"testing-store-instance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#testing-store-instance"}},[t._v("#")]),t._v(" Testing Store Instance")]),t._v(" "),s("ul",[s("li",[t._v("Uses mutations and actions as inputs")]),t._v(" "),s("li",[t._v("State is the output")]),t._v(" "),s("li",[t._v("Requires the use of "),s("code",[t._v("localVue")]),t._v(" when creating the store to avoide leaky tests")])]),t._v(" "),s("h4",{attrs:{id:"pros-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pros-2"}},[t._v("#")]),t._v(" Pros")]),t._v(" "),s("ul",[s("li",[t._v("Avoids mocking and brittle tests")]),t._v(" "),s("li",[t._v("Refactoring does not break test unless contract changes")])]),t._v(" "),s("h4",{attrs:{id:"cons-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cons-2"}},[t._v("#")]),t._v(" Cons")]),t._v(" "),s("ul",[s("li",[t._v("Debugging is more difficult")])]),t._v(" "),s("h2",{attrs:{id:"vue-router"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router"}},[t._v("#")]),t._v(" Vue Router")]),t._v(" "),s("ul",[s("li",[t._v("Our current structure does not warrant testing the vue router")]),t._v(" "),s("li",[t._v("If there is logic used for creating "),s("code",[t._v("RouteLink")]),t._v(" items, we should unit test that functionality, which requires stubbing")]),t._v(" "),s("li",[t._v("When testing a vue router, it is important to use localVue")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://vuex.vuejs.org/guide/testing.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vuex Testing"),s("OutboundLink")],1)]),t._v(" "),s("h2",{attrs:{id:"resources"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#resources"}},[t._v("#")]),t._v(" Resources")]),t._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://vue-test-utils.vuejs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue Test Utils"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://vuejsdevelopers.com/2019/08/26/vue-what-to-unit-test-components/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Knowing What To Test â€” Vue Component Unit Testing"),s("OutboundLink")],1)]),t._v(" "),s("li",[s("a",{attrs:{href:"https://www.dev-tips-and-tricks.com/how-to-unit-test-a-vuex-store",target:"_blank",rel:"noopener noreferrer"}},[t._v("How to unit test a vuex Store"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=n.exports}}]);